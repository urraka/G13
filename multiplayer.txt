CLIENT
  - main player
    - how is it different form others? input/simulation (client prediction)
  - list of other players
    - state buffer
    - interpolation
    - 100ms behind
    - player name
    - state (dead, alive, etc)
  - current map
  - rendering

SERVER
  - map
  - players
    - simulation
    - name
    - state
    - input buffer

PLAYER (shared between client/server)
  - should have some way to inject input, either from local input or network
  - update logic should simulate or interpolate
  - nickname


* client owns the game state, or the game state owns the client? or is the client a game state?
* let the client and server handle ALL message stuff?
* each player has his own tick?
* soldier could make the interpolation, give it some target state and let it do the work
* soldier state should be in soldier
* datastream stuff should work on bits, not bytes
* make client/server interact with a game state which holds the players
* make some players list wrapper to get by id, add, remove, etc
* make player have id and some index to keep track of both player arrays
* for later on.. retrieve server info before starting all the client/server stuff
* separate player info from game state stuff and make client request each player info
* add some key to start/stop server, and some state when not connected
* all net messages into net::msg namespace, and simplify stuff somehow
* redefine protocol
* use magic defines for serialization/unserialization

[msg]
|- create<T> (ENetPacket*) # one object "pool", calls T::read(), return NULL if invalid
|- create    (ENetPacket*)
|- destroy<T>(Message*)
|- destroy   (Message*)

msg::Message
|- type()
|- serialize()
|
|> msg::SpecificMessage
|  |- read(bytes*, length) # returns false if invalid
|  |- serialize()
|  |- [public fields]

net::PacketData # make it pooled
|- new
|- delete
|- data[1350] # enet takes like 28 bytes for header
|- length

net::Multiplayer
|- mode (Client, Server)
|- net::Players
|- Map
|- tick
|- ENetHost*
|- send(Message*, ENetPeer*)
|
|> net::Server : net::Multiplayer
|  |- state (Running, Stopping, Stopped)
|  |- broadcast(Message*)
|
|> net::Client : net::Multiplayer
   |- state (Connected, Connecting Disconnected)
   |- localPlayerId
   |- ENetPeer*

net::Player
|- onInput()
|- onGameState()

stt::Multiplayer # can have client, server or both
|- net::Server
|- net::Client

PROTOCOL
  Client
    on connect    -> send msg::Login
    on msg::Info  -> wait for msg::Join messages for all player ids in gameinfo
    on msg::Join  -> update gameinfo and player info, when all players info is received send (or be able to send) msg::SpawnRequest
    on msg::Leave -> update gameinfo
    on msg::Spawn -> start playing
    on playing    -> send msg::Input
    on msg::State -> update other players, adjust own position if necessary

  Server
    on connect


Multiplayer
+- tick
+- map
+- players
+- connection (ENetHost*)
|
+- update(dt)
|  +- poll network (enet_host_service)
|     +- EVENT_CONNECT
|     |  +- onConnect(peer)
|     |
|     +- EVENT_DISCONNECT
|     |  +- onDisconnect(peer)
|     |
|     +- EVENT_PACKET
|        +- msg = unserialize(packet)
|        +- onMessage(msg, peer)
|
+- send(msg, peer)
|  +- packet = serialize(msg)
|  +- packet->type = RELIABLE
|  +- if msg->type == GameState: packet->type = UNSEQUENCED
|  +- if peer != NULL: send_packet(packet, peer)
|  +- if peer == NULL: broadcast_packet(packet)
|
+- broadcast(msg)
|  +- send(msg, NULL)
|
+- Server : Multiplayer
   +- state (Running|Stopped|Stopping)
   |
   +- start(port)
   |  +- connection = host_create()
   |  +- connection->listen(port)
   |  +- tick = 1
   |  +- state = Running
   |  +- map = load_map()
   |  +- initialize_players()
   |     +- player->state = Disconnected
   |     +- player->peer = NULL
   |     +- player->mode = ServerMode
   |
   +- stop()
   |  +- state = Stopping
   |  +- for each connected player
   |     +- peer_disconnect(player->peer)
   |
   +- update(dt)
      +- Multiplayer::update(dt)
         +- onConnect(peer)
         |  +- if state == Stopping
         |  |  +- peer_reset(peer)
         |  |  +- return
         |  |
         |  +- player = findDisconnectedPlayer()
         |  +- peer->data = player
         |  +- player->onConnecting(peer)
         |     +- player->state = Connecting
         |     +- player->peer = peer
         |     +- player->timeout = 0
         |
         +- onDisconnect(peer)
         |  +- player = peer->data
         |  +- player->onDisconnect()
         |  |  +- player->state = Disconnected
         |  |
         |  +- msg = msg::PlayerDisconnect
         |  +- msg->id = player->id
         |  +- broadcast(msg)
         |
         +- onMessage(msg, peer)
            +- player = peer->data
            +- switch (msg->type)
               +- onPlayerLogin(player, msg)
               |  +- player->onConnect()
               |  |  +- state = Connected
               |  |
               |  +- info = msg::ServerInfo
               |  +- info->tick = tick
               |  +- info->clientId = player->id
               |  +- info->players = [array of player id's]
               |  +- send(info, player->peer)
               |  |
               |  +- connect = msg::PlayerConnect
               |  +- connect->id = player->id
               |  +- broadcast(connect)
               |  |
               |  +- for each other connected player
               |     +- connect = msg::PlayerConnect
               |     +- connect->id = otherPlayer->id
               |     +- send(connect, player->peer)
               |
               +- onPlayerReady(player, msg)
               |  +- msg = msg::PlayerJoin
               |  +- msg->tick = tick
               |  +- msg->id = player->id
               |  +- msg->spawnPosition = map->spawnPosition()
               |  +- broadcast(msg)
               |  +- player->onJoin(tick, map, msg->spawnPosition)
               |     +- player->state = Playing
               |     +- player->soldier->map = map
               |     +- player->soldier->position = spawnPosition
               |     +- player->lastInputTick = tick - 1
               |     +- player->inputs->clear()
               |
               +- onPlayerInput(player, msg)