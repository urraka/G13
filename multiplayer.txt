CLIENT
  - main player
    - how is it different form others? input/simulation (client prediction)
  - list of other players
    - state buffer
    - interpolation
    - 100ms behind
    - player name
    - state (dead, alive, etc)
  - current map
  - rendering

SERVER
  - map
  - players
    - simulation
    - name
    - state
    - input buffer

PLAYER (shared between client/server)
  - should have some way to inject input, either from local input or network
  - update logic should simulate or interpolate
  - nickname


* client owns the game state, or the game state owns the client? or is the client a game state?
* let the client and server handle ALL message stuff?
* each player has his own tick?
* soldier could make the interpolation, give it some target state and let it do the work
* soldier state should be in soldier
* datastream stuff should work on bits, not bytes
* make client/server interact with a game state which holds the players
* make some players list wrapper to get by id, add, remove, etc
* make player have id and some index to keep track of both player arrays
* for later on.. retrieve server info before starting all the client/server stuff
* separate player info from game state stuff and make client request each player info
* add some key to start/stop server, and some state when not connected
* all net messages into net::msg namespace, and simplify stuff somehow
* redefine protocol
* use magic defines for serialization/unserialization

[msg]
|- create<T> (ENetPacket*) # one object "pool", calls T::read(), return NULL if invalid
|- create    (ENetPacket*)
|- destroy<T>(Message*)
|- destroy   (Message*)

msg::Message
|- type()
|- serialize()
|
|> msg::SpecificMessage
|  |- read(bytes*, length) # returns false if invalid
|  |- serialize()
|  |- [public fields]

net::PacketData # make it pooled
|- new
|- delete
|- data[1350] # enet takes like 28 bytes for header
|- length

net::Multiplayer
|- mode (Client, Server)
|- net::Players
|- Map
|- tick
|- ENetHost*
|- send(Message*, ENetPeer*)
|
|> net::Server : net::Multiplayer
|  |- state (Running, Stopping, Stopped)
|  |- broadcast(Message*)
|
|> net::Client : net::Multiplayer
   |- state (Connected, Connecting Disconnected)
   |- localPlayerId
   |- ENetPeer*

net::Player
|- onInput()
|- onGameState()

stt::Multiplayer # can have client, server or both
|- net::Server
|- net::Client

PROTOCOL
  Client
    on connect    -> send msg::Login
    on msg::Info  -> wait for msg::Join messages for all player ids in gameinfo
    on msg::Join  -> update gameinfo and player info, when all players info is received send (or be able to send) msg::SpawnRequest
    on msg::Leave -> update gameinfo
    on msg::Spawn -> start playing
    on playing    -> send msg::Input
    on msg::State -> update other players, adjust own position if necessary

  Server
    on connect