Networking
  - Consider adding range checks on packet serialization.
  - Check where peer->mtu is negotiated.
  - Server asserts when client tick > server tick. Make it kill the client.
  - The number of ticks that remote players are rendered behind is hardcoded, fix that.
  - Extrapolation
  - Client side prediction is not correcting if out of sync.

Game
  - New soldier animations with ability to aim at arbitrary angles.
  - Figure out how to simplify debug output.
  - Replace network.txt with config.cfg and move it ro root directory.
  - Separate collision map from map rendering stuff.
  - Find collision bug and fix it, I FUCKING SAW IT.
    x Run from bottom-left to the right until blocked by the "wall", then walk left.
  - Auto-record every fucking gameplay and store in new files with dates and shit.
  - Consider making components private with methods to access as const.

Graphics
  - Add text rendering.
    x Remove Font::Page, mix all sizes in same atlas.
    x Let atlas handle its own size and enlarging.
    x Glyph default values.
    - Check if there's a more efficient technique for copying from one texture to another.
    - Font->kerning()
  / Store max texture size.
    - Double check if done right.
  - Add global_opacity to shaders and gfx::opacity() to set it.
  x Find the proper way to choose the mipmap generation method.
  - Add ability to set own mipmaps.

General
  - Test if all the refactoring works on linux/osx/ios.
  - Consider making each module a library to include into the game.
  - Attempt to add iOS/iOS-simulator to makefile and get rid of xcode project.

System
  - Split keyboard event in KeyPressedEvent/KeyReleasedEvent.
  - Consider renaming events so structs are like sys::KeyPressed and type sys::KeyPressedEvent.
  - Framebuffer size vs window size.
  - Try that clock formula or use double instead.
  - iOS: callbacks for touch/movement events.

Math
  - Add some overflow checks in fpm functions (example: in length(), if (x.x or x.y > 175 warning! 175*175 = 30625))
  - Consider using int64 in some functions if necessary.

Archive
  x Modules: sys, gfx, math, hlp, g13.
  x Move fpm namespace inside math namespace.
  x Each directory under src/ should be named after a namespace.
  x Each module can have a general include (gfx/gfx.h, sys/sys.h, math/math.h, etc)
  x Move platform.h away from system.
  x Consider moving all System stuff into sys namespace, Graphics to gfx and Math to math.
  x Replace using directives with typedefs.
  x Add g13/math.h
  x Remove Game class and turn it into global functions in g13 namespace.
  x Move all game classes into g13 namespace.
  x Clock goes away, just do sys::time(), sys::milliseconds(), etc.
  x Add all external includes to project and all libs compiled for the different systems.
  x Massive refactoring.
  x Switch to GLFW3 (when ready).
  x Revisit keyboard/char input stuff.
  x Decide what to do with platform.h, which is needed across modules.
  x Remove unnecesary includes from Graphics.h and add gfx.h as the general file to include.
  x Remove dependency with Math and System.
  x Test buffer state keeping.
  x Add Image class which loads PNG into a memory buffer.
  x Make texture class use Image class and add ability to load from buffer.
  x Add mipmaping support with glGenMipmaps and GL_GENERATE_MIPMAP or whatever (for 2.1).
  x Add shader type to VBO object so it binds it for you.
  x Add #version when creating shader.
  x Check for GL_ES in shaders.
  x Even better, add preamble #defining lowp, etc to nothing on desktop and add precision on GLES2.
  x Add glsl step on makefile.
  x vbo/ibo -> allocate() should delete buffer and reallocate if necessary.
  x SpriteBatch might be able to share the same IBO across instances.
  x Graphics turns into global functions in gfx namespace.
  x Graphics initialization through gfx::initialize().
  x Design a better approach to handle shaders.
  x Different gfx objects not created from graphics instance anymore (just using new).
  x Add opacity to sprites.
  x Coding convention: remove identation inside namespaces.
  x Add some kind of switch to enable/disable server.
  x Messages
    x Nick
    x SpawnRequest
    x Input
    x Start
    x PlayerJoin
    x PlayerLeave
    x Gamestate
    x Spawn
  x Soldier state needs animation id.
  x Add tick to every message so unordered packets can be used.
  x Add own allocation for enet.
  x Add some SoldierState and embed it inside PlayerInfo
  x Decide if server updates only when receiving data.
  x Design packet structures/format.
  / Self-contained loop with time measuring and crap in Server class.
  x Decide how to handle server (standalone, along with client, use another thread, etc).
    * Standalone, then find its way into the client.
  x Decide what object will keep all the game state (players, bullets, etc).
    * Server class will be main container (for now).
  x Add all messages in a Message directory and divide them in h/cpp.
  x Simplify Packet so it contains only one Message.
  x Add DataReader/DataWriter to access binary data in a network friendly way.
  x Player should be a more dedicated class. Share it between client and server?
  x Read about networking and decide what to do first.
  x Consider removing init() from Scene and initialize on constructor, assuming it's always created on the heap with new.
  x Rename Scene to State.
  x Use namespaces for states, entities and components (stt, ent, cmp).
  x Add some method to switch Game state.
  x Fix replay crashing game on release.
  x Move all debug outputs to debugger object.
  x Add global Debugger object which everyone has access to.
  x Move the debug drawing to Debugger object.
  x Think of a way to remove Debugger calls on release mode.
  x Check for room before jumping to avoid insane bouncing.
  x Add ducking.
  x Sort headers again so Graphics doesn't depend on useless stuff.
  x interpolable<T> with T previous and T current, and methods update(), update(T value) and value(float percent).
  x Move glewInit to system module to remove platform specific code in graphics module.
  x Add SoldierGraphics component.
  x Make camera take a vec2* instead of Entity*.
  x Consider Removing Entity class.
  x iOS: set statusbar orientation when orientation changed.
  x Fix not POD warnings generated by offsetof.
  x Replace bufferFlagged with pointedBuffer and call attributes functions if pointedBuffer != currentBuffer.




********************************************************************************
*                              Multiplayer Notes                               *
********************************************************************************

CLIENT
  - main player
    - how is it different form others? input/simulation (client prediction)
  - list of other players
    - state buffer
    - interpolation
    - 100ms behind
    - player name
    - state (dead, alive, etc)
  - current map
  - rendering

SERVER
  - map
  - players
    - simulation
    - name
    - state
    - input buffer

PLAYER (shared between client/server)
  - should have some way to inject input, either from local input or network
  - update logic should simulate or interpolate
  - nickname


* client owns the game state, or the game state owns the client? or is the client a game state?
* let the client and server handle ALL message stuff?
* each player has his own tick?
* soldier could make the interpolation, give it some target state and let it do the work
* soldier state should be in soldier
* datastream stuff should work on bits, not bytes
* make client/server interact with a game state which holds the players
* make some players list wrapper to get by id, add, remove, etc
* make player have id and some index to keep track of both player arrays
* for later on.. retrieve server info before starting all the client/server stuff
* separate player info from game state stuff and make client request each player info
* add some key to start/stop server, and some state when not connected
* all net messages into net::msg namespace, and simplify stuff somehow
* redefine protocol
* use magic defines for serialization/unserialization

[msg]
|- create<T> (ENetPacket*) # one object "pool", calls T::read(), return NULL if invalid
|- create    (ENetPacket*)
|- destroy<T>(Message*)
|- destroy   (Message*)

msg::Message
|- type()
|- serialize()
|
|> msg::SpecificMessage
|  |- read(bytes*, length) # returns false if invalid
|  |- serialize()
|  |- [public fields]

net::PacketData # make it pooled
|- new
|- delete
|- data[1350] # enet takes like 28 bytes for header
|- length

net::Multiplayer
|- mode (Client, Server)
|- net::Players
|- Map
|- tick
|- ENetHost*
|- send(Message*, ENetPeer*)
|
|> net::Server : net::Multiplayer
|  |- state (Running, Stopping, Stopped)
|  |- broadcast(Message*)
|
|> net::Client : net::Multiplayer
   |- state (Connected, Connecting Disconnected)
   |- localPlayerId
   |- ENetPeer*

net::Player
|- onInput()
|- onGameState()

stt::Multiplayer # can have client, server or both
|- net::Server
|- net::Client

PROTOCOL
  Client
    on connect    -> send msg::Login
    on msg::Info  -> wait for msg::Join messages for all player ids in gameinfo
    on msg::Join  -> update gameinfo and player info, when all players info is received send (or be able to send) msg::SpawnRequest
    on msg::Leave -> update gameinfo
    on msg::Spawn -> start playing
    on playing    -> send msg::Input
    on msg::State -> update other players, adjust own position if necessary

  Server
    on connect


Multiplayer
+- tick
+- map
+- players
+- connection (ENetHost*)
|
+- update(dt)
|  +- poll network (enet_host_service)
|     +- EVENT_CONNECT
|     |  +- onConnect(peer)
|     |
|     +- EVENT_DISCONNECT
|     |  +- onDisconnect(peer)
|     |
|     +- EVENT_PACKET
|        +- msg = unserialize(packet)
|        +- onMessage(msg, peer)
|
+- send(msg, peer)
|  +- packet = serialize(msg)
|  +- packet->type = RELIABLE
|  +- if msg->type == GameState: packet->type = UNSEQUENCED
|  +- if peer != NULL: send_packet(packet, peer)
|  +- if peer == NULL: broadcast_packet(packet)
|
+- broadcast(msg)
|  +- send(msg, NULL)
|
+- Server : Multiplayer
   +- state (Running|Stopped|Stopping)
   |
   +- start(port)
   |  +- connection = host_create()
   |  +- connection->listen(port)
   |  +- tick = 1
   |  +- state = Running
   |  +- map = load_map()
   |  +- initialize_players()
   |     +- player->state = Disconnected
   |     +- player->peer = NULL
   |     +- player->mode = ServerMode
   |
   +- stop()
   |  +- state = Stopping
   |  +- for each connected player
   |     +- peer_disconnect(player->peer)
   |
   +- update(dt)
      +- Multiplayer::update(dt)
         +- onConnect(peer)
         |  +- if state == Stopping
         |  |  +- peer_reset(peer)
         |  |  +- return
         |  |
         |  +- player = findDisconnectedPlayer()
         |  +- peer->data = player
         |  +- player->onConnecting(peer)
         |     +- player->state = Connecting
         |     +- player->peer = peer
         |     +- player->timeout = 0
         |
         +- onDisconnect(peer)
         |  +- player = peer->data
         |  +- player->onDisconnect()
         |  |  +- player->state = Disconnected
         |  |
         |  +- msg = msg::PlayerDisconnect
         |  +- msg->id = player->id
         |  +- broadcast(msg)
         |
         +- onMessage(msg, peer)
            +- player = peer->data
            +- switch (msg->type)
               +- onPlayerLogin(player, msg)
               |  +- player->onConnect()
               |  |  +- state = Connected
               |  |
               |  +- info = msg::ServerInfo
               |  +- info->tick = tick
               |  +- info->clientId = player->id
               |  +- info->players = [array of player id's]
               |  +- send(info, player->peer)
               |  |
               |  +- connect = msg::PlayerConnect
               |  +- connect->id = player->id
               |  +- broadcast(connect)
               |  |
               |  +- for each other connected player
               |     +- connect = msg::PlayerConnect
               |     +- connect->id = otherPlayer->id
               |     +- send(connect, player->peer)
               |
               +- onPlayerReady(player, msg)
               |  +- msg = msg::PlayerJoin
               |  +- msg->tick = tick
               |  +- msg->id = player->id
               |  +- msg->spawnPosition = map->spawnPosition()
               |  +- broadcast(msg)
               |  +- player->onJoin(tick, map, msg->spawnPosition)
               |     +- player->state = Playing
               |     +- player->soldier->map = map
               |     +- player->soldier->position = spawnPosition
               |     +- player->lastInputTick = tick - 1
               |     +- player->inputs->clear()
               |
               +- onPlayerInput(player, msg)